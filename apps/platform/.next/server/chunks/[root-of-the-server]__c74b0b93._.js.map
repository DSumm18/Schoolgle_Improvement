{"version":3,"sources":["../../../../../apps/platform/src/lib/cloud-service.ts"],"sourcesContent":["// --- Types ---\r\n\r\nexport interface FileMetadata {\r\n    id: string;\r\n    name: string;\r\n    mimeType: string;\r\n}\r\n\r\nexport interface FileMetadataExtended extends FileMetadata {\r\n    modifiedTime?: string;\r\n    size?: number;\r\n    webViewLink?: string;\r\n    folderPath?: string;\r\n    parentId?: string;\r\n    isFolder?: boolean;\r\n}\r\n\r\nexport interface ScanProgress {\r\n    totalFiles: number;\r\n    processedFiles: number;\r\n    currentFile?: string;\r\n    currentFolder?: string;\r\n}\r\n\r\n// --- Google Drive Functions ---\r\n\r\n/**\r\n * List files in a single folder (non-recursive)\r\n */\r\nexport async function listGoogleFiles(accessToken: string, folderId: string): Promise<FileMetadata[]> {\r\n    const query = `'${folderId}' in parents and trashed = false`;\r\n    const response = await fetch(\r\n        `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(query)}&fields=files(id,name,mimeType)`,\r\n        {\r\n            headers: { Authorization: `Bearer ${accessToken}` },\r\n        }\r\n    );\r\n\r\n    if (!response.ok) {\r\n        const errorBody = await response.text();\r\n        console.error(`Google Drive API Error Body: ${errorBody}`);\r\n        throw new Error(`Google Drive API error: ${response.status} ${response.statusText} - ${errorBody}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    return data.files;\r\n}\r\n\r\n/**\r\n * Recursively list all files in folder tree\r\n */\r\nexport async function listGoogleFilesRecursive(\r\n    accessToken: string,\r\n    folderId: string,\r\n    onProgress?: (progress: ScanProgress) => void,\r\n    currentPath: string = 'Root'\r\n): Promise<FileMetadataExtended[]> {\r\n    const allFiles: FileMetadataExtended[] = [];\r\n\r\n    // Get all items in current folder\r\n    const query = `'${folderId}' in parents and trashed = false`;\r\n    const response = await fetch(\r\n        `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(query)}&fields=files(id,name,mimeType,modifiedTime,size,webViewLink)&pageSize=1000`,\r\n        {\r\n            headers: { Authorization: `Bearer ${accessToken}` },\r\n        }\r\n    );\r\n\r\n    if (!response.ok) {\r\n        throw new Error(`Google Drive API error: ${response.status} ${response.statusText}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    const items = data.files || [];\r\n\r\n    // Separate folders and files\r\n    const folders: FileMetadataExtended[] = [];\r\n    const files: FileMetadataExtended[] = [];\r\n\r\n    items.forEach((item: any) => {\r\n        const metadata: FileMetadataExtended = {\r\n            id: item.id,\r\n            name: item.name,\r\n            mimeType: item.mimeType,\r\n            modifiedTime: item.modifiedTime,\r\n            size: item.size ? parseInt(item.size) : undefined,\r\n            webViewLink: item.webViewLink,\r\n            folderPath: currentPath,\r\n            parentId: folderId,\r\n            isFolder: item.mimeType === 'application/vnd.google-apps.folder'\r\n        };\r\n\r\n        if (metadata.isFolder) {\r\n            folders.push(metadata);\r\n        } else {\r\n            files.push(metadata);\r\n        }\r\n    });\r\n\r\n    // Add files from current folder\r\n    allFiles.push(...files);\r\n\r\n    // Report progress\r\n    if (onProgress) {\r\n        onProgress({\r\n            totalFiles: allFiles.length,\r\n            processedFiles: 0,\r\n            currentFolder: currentPath\r\n        });\r\n    }\r\n\r\n    // Recursively process subfolders\r\n    for (const folder of folders) {\r\n        const folderPath = `${currentPath} > ${folder.name}`;\r\n        console.log(`[Scan] Entering folder: ${folderPath}`);\r\n\r\n        const subFiles = await listGoogleFilesRecursive(\r\n            accessToken,\r\n            folder.id,\r\n            onProgress,\r\n            folderPath\r\n        );\r\n\r\n        allFiles.push(...subFiles);\r\n    }\r\n\r\n    return allFiles;\r\n}\r\n\r\n/**\r\n * Get detailed metadata for a specific file\r\n */\r\nexport async function getGoogleFileMetadata(\r\n    accessToken: string,\r\n    fileId: string\r\n): Promise<FileMetadataExtended> {\r\n    const response = await fetch(\r\n        `https://www.googleapis.com/drive/v3/files/${fileId}?fields=id,name,mimeType,modifiedTime,size,webViewLink,parents`,\r\n        {\r\n            headers: { Authorization: `Bearer ${accessToken}` },\r\n        }\r\n    );\r\n\r\n    if (!response.ok) {\r\n        throw new Error(`Google Drive API error: ${response.status} ${response.statusText}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n\r\n    return {\r\n        id: data.id,\r\n        name: data.name,\r\n        mimeType: data.mimeType,\r\n        modifiedTime: data.modifiedTime,\r\n        size: data.size ? parseInt(data.size) : undefined,\r\n        webViewLink: data.webViewLink,\r\n        parentId: data.parents?.[0]\r\n    };\r\n}\r\n\r\n/**\r\n * Download file content\r\n */\r\nexport async function getGoogleFileContent(accessToken: string, fileId: string): Promise<Buffer> {\r\n    const response = await fetch(\r\n        `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,\r\n        {\r\n            headers: { Authorization: `Bearer ${accessToken}` },\r\n        }\r\n    );\r\n\r\n    if (!response.ok) {\r\n        throw new Error(`Google Drive Download error: ${response.statusText}`);\r\n    }\r\n\r\n    const arrayBuffer = await response.arrayBuffer();\r\n    return Buffer.from(arrayBuffer);\r\n}\r\n\r\n/**\r\n * Export Google Workspace files as text\r\n * Supports: Google Docs → text/plain, Google Sheets → text/csv\r\n */\r\nexport async function exportGoogleDoc(\r\n    accessToken: string,\r\n    fileId: string,\r\n    mimeType: string\r\n): Promise<string> {\r\n    // Determine export format based on Google Workspace type\r\n    let exportMimeType = 'text/plain';\r\n\r\n    if (mimeType === 'application/vnd.google-apps.document') {\r\n        exportMimeType = 'text/plain'; // Google Docs → plain text\r\n    } else if (mimeType === 'application/vnd.google-apps.spreadsheet') {\r\n        exportMimeType = 'text/csv'; // Google Sheets → CSV\r\n    } else if (mimeType === 'application/vnd.google-apps.presentation') {\r\n        exportMimeType = 'text/plain'; // Google Slides → plain text\r\n    } else {\r\n        throw new Error(`Unsupported Google Workspace type: ${mimeType}`);\r\n    }\r\n\r\n    const response = await fetch(\r\n        `https://www.googleapis.com/drive/v3/files/${fileId}/export?mimeType=${encodeURIComponent(exportMimeType)}`,\r\n        {\r\n            headers: { Authorization: `Bearer ${accessToken}` },\r\n        }\r\n    );\r\n\r\n    if (!response.ok) {\r\n        throw new Error(`Google Drive Export error: ${response.statusText}`);\r\n    }\r\n\r\n    return await response.text();\r\n}\r\n\r\n/**\r\n * Check if file needs to be re-scanned (based on modification time)\r\n */\r\nexport function shouldRescanFile(\r\n    fileModifiedTime: string,\r\n    lastScannedTime?: string\r\n): boolean {\r\n    if (!lastScannedTime) {\r\n        return true; // Never scanned before\r\n    }\r\n\r\n    const fileDate = new Date(fileModifiedTime);\r\n    const scannedDate = new Date(lastScannedTime);\r\n\r\n    return fileDate > scannedDate; // File modified after last scan\r\n}\r\n\r\n// --- OneDrive Functions ---\r\n\r\n/**\r\n * List files in a single folder (non-recursive)\r\n */\r\nexport async function listOneDriveFiles(accessToken: string, folderId: string): Promise<FileMetadata[]> {\r\n    const response = await fetch(\r\n        `https://graph.microsoft.com/v1.0/me/drive/items/${folderId}/children?select=id,name,file`,\r\n        {\r\n            headers: { Authorization: `Bearer ${accessToken}` },\r\n        }\r\n    );\r\n\r\n    if (!response.ok) {\r\n        throw new Error(`Microsoft Graph API error: ${response.statusText}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    // Map OneDrive items to common metadata\r\n    return data.value.map((item: any) => ({\r\n        id: item.id,\r\n        name: item.name,\r\n        mimeType: item.file?.mimeType || 'application/octet-stream'\r\n    }));\r\n}\r\n\r\n/**\r\n * Recursively list all files in OneDrive folder tree\r\n */\r\nexport async function listOneDriveFilesRecursive(\r\n    accessToken: string,\r\n    folderId: string,\r\n    onProgress?: (progress: ScanProgress) => void,\r\n    currentPath: string = 'Root'\r\n): Promise<FileMetadataExtended[]> {\r\n    const allFiles: FileMetadataExtended[] = [];\r\n\r\n    // Get all items in current folder\r\n    const response = await fetch(\r\n        `https://graph.microsoft.com/v1.0/me/drive/items/${folderId}/children?select=id,name,file,folder,lastModifiedDateTime,size,webUrl`,\r\n        {\r\n            headers: { Authorization: `Bearer ${accessToken}` },\r\n        }\r\n    );\r\n\r\n    if (!response.ok) {\r\n        throw new Error(`Microsoft Graph API error: ${response.statusText}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n    const items = data.value || [];\r\n\r\n    // Separate folders and files\r\n    const folders: FileMetadataExtended[] = [];\r\n    const files: FileMetadataExtended[] = [];\r\n\r\n    items.forEach((item: any) => {\r\n        const metadata: FileMetadataExtended = {\r\n            id: item.id,\r\n            name: item.name,\r\n            mimeType: item.file?.mimeType || 'application/octet-stream',\r\n            modifiedTime: item.lastModifiedDateTime,\r\n            size: item.size,\r\n            webViewLink: item.webUrl,\r\n            folderPath: currentPath,\r\n            parentId: folderId,\r\n            isFolder: !!item.folder\r\n        };\r\n\r\n        if (metadata.isFolder) {\r\n            folders.push(metadata);\r\n        } else {\r\n            files.push(metadata);\r\n        }\r\n    });\r\n\r\n    // Add files from current folder\r\n    allFiles.push(...files);\r\n\r\n    // Report progress\r\n    if (onProgress) {\r\n        onProgress({\r\n            totalFiles: allFiles.length,\r\n            processedFiles: 0,\r\n            currentFolder: currentPath\r\n        });\r\n    }\r\n\r\n    // Recursively process subfolders\r\n    for (const folder of folders) {\r\n        const folderPath = `${currentPath} > ${folder.name}`;\r\n        console.log(`[Scan] Entering folder: ${folderPath}`);\r\n\r\n        const subFiles = await listOneDriveFilesRecursive(\r\n            accessToken,\r\n            folder.id,\r\n            onProgress,\r\n            folderPath\r\n        );\r\n\r\n        allFiles.push(...subFiles);\r\n    }\r\n\r\n    return allFiles;\r\n}\r\n\r\n/**\r\n * Download OneDrive file content\r\n */\r\nexport async function getOneDriveFileContent(accessToken: string, fileId: string): Promise<Buffer> {\r\n    const response = await fetch(\r\n        `https://graph.microsoft.com/v1.0/me/drive/items/${fileId}/content`,\r\n        {\r\n            headers: { Authorization: `Bearer ${accessToken}` },\r\n        }\r\n    );\r\n\r\n    if (!response.ok) {\r\n        throw new Error(`OneDrive Download error: ${response.statusText}`);\r\n    }\r\n\r\n    const arrayBuffer = await response.arrayBuffer();\r\n    return Buffer.from(arrayBuffer);\r\n}\r\n\r\n// --- Utility Functions ---\r\n\r\n/**\r\n * Batch process files with rate limiting\r\n */\r\nexport async function batchProcessFiles<T, R>(\r\n    items: T[],\r\n    processFunc: (item: T) => Promise<R>,\r\n    options: {\r\n        batchSize?: number;\r\n        delayMs?: number;\r\n        onProgress?: (current: number, total: number) => void;\r\n    } = {}\r\n): Promise<R[]> {\r\n    const {\r\n        batchSize = 5,\r\n        delayMs = 1000,\r\n        onProgress\r\n    } = options;\r\n\r\n    const results: R[] = [];\r\n\r\n    for (let i = 0; i < items.length; i += batchSize) {\r\n        const batch = items.slice(i, i + batchSize);\r\n\r\n        const batchResults = await Promise.all(\r\n            batch.map(item => processFunc(item))\r\n        );\r\n\r\n        results.push(...batchResults);\r\n\r\n        if (onProgress) {\r\n            onProgress(Math.min(i + batchSize, items.length), items.length);\r\n        }\r\n\r\n        // Delay between batches to avoid rate limiting\r\n        if (i + batchSize < items.length) {\r\n            await new Promise(resolve => setTimeout(resolve, delayMs));\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n"],"names":[],"mappings":"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"}